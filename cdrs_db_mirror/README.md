# cdrs_db_mirror

A crate with several proc macros that makes it safer and more ergonomic to query the database.

## DBMirror
Generates commonly used queries for an annotated struct.
Note: your properties needs to be correctly annotated with partition_key or clustering_key. If you don't want to do
this manually, consider using cdrs_to_rust, which places this annotation correctly automatically.

The following is generated by this macro:
- a primary key struct, representing the primary key as in the database. The primary key struct is named: `<my_struct>PrimaryKey`.
If you want to add custom derives to the primary key struct, add a comma separates list of derives for environment
variable: `DERIVE_CDRS_PK`.
- various queries that manipulate/queries a single row:
    - select
    - delete
    - insert
    - update:
        - single property (all properties have a update method)
        - by enum: for every property that can be updated, a variant is added to the `<my_struct>UpdateableColumns` enum.
            - dynamic by enum. This is a single method that takes a the updatable enum and updates the corresponding property.
            - dynamic by vec enum. Single method that takes a vec of the updatable enums and dynamically creates the update statement. 
        Note: this returns a `String` unlike the other statements that returns `&'static str`
        

Tip: this crate generates several methods to acquire the primary key of a struct and queries. Most of the time,
you want to directly insert a struct and not acquire the query and manually insert them. You should write your
own implementation of trait Writer inside cdrs_query_writer. You can map your custom functions here to the functions
of db_mirror and implement your own logic. See example_impl_writer for an example.

## DBJson
Provides a way to automatically do a conversation between the database 'string' datatype and a Rust struct. 
Note: the Rust struct must be serde::Serialize and serde::Deserialize.

This way, you can write something like this:

```rust
#[derive(Serialize, Deserialize, DBJson)]
struct SomeStruct { 
    property: i32
}

#[derive(Serialize, Deserialize, DBMirror)]
struct AnotherStruct { 
    #[json_mapped]
    property: SomeStruct
}

fn insert() {
    let another_struct = AnotherStruct { 
        property: SomeStruct { 
            property: 1
        }   
    };

    let (query, values) = AnotherStruct::insert_qv(&another_struct);
    
    assert_eq!(query, "insert into AnotherStruct(property) values (?)");

    let values = serde_json::to_string(&another_struct.property).unwrap().into();

    assert_eq!(values, query_values!(values));
}
```

No more manual serialization and deserialization.